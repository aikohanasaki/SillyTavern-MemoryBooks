# 📕 Memory Books (SillyTavern 拡張機能)

自動的かつ構造化された信頼性の高いメモリ（記憶）作成を行うための、次世代 SillyTavern 拡張機能です。チャット内のシーンをマークし、AI を使用して JSON ベースの要約を生成し、それらを「[ベクトル化](#vectorized)」されたエントリとしてロアブックに保存します。グループチャット、高度なプロファイル管理、および堅牢な API/モデル処理をサポートしています。

### ❓ 用語集
- Scene (シーン) → Memory (記憶)
- Many Scenes (複数のシーン) → Arc Summary (アークサマリー/章の要約)
- Always-On (常時稼働) → Side Prompt (Tracker) / サイドプロンプト（トラッカー）

## ❗ 最初にお読みください！

まずはここから：
* ⚠️‼️ インストールに関する注意点（特にテキスト補完 API を実行している場合）については、[必須要件](#-prerequisites)をお読みください。
* ❓ [よくある質問 (FAQ)](#FAQ)
* 🛠️ [トラブルシューティング](#Troubleshooting)

その他のリンク：
* 📘 [ユーザーガイド (EN)](USER_GUIDE.md)
* 📋 [バージョン履歴 & 更新ログ](changelog.md)
* 💡 [📕 Memory Books と 📚 Lorebook Ordering の併用について](https://github.com/aikohanasaki/SillyTavern-LorebookOrdering/blob/main/guides/STMB%20and%20STLO%20-%20English.md)

---

### 📚 Lorebook Ordering (STLO) でパワーアップ

高度な記憶の整理とより深いストーリー統合のために、STMB を [SillyTavern-LorebookOrdering (STLO)](https://github.com/aikohanasaki/SillyTavern-LorebookOrdering/blob/main/guides/STMB%20and%20STLO%20-%20English.md) と併用することを強くお勧めします。ベストプラクティス、セットアップ手順、ヒントについてはガイドをご覧ください！

> 注意：様々な言語をサポートしています。リストについては [`/locales`](locales) フォルダを参照してください。国際化/ローカライズされた Readme とユーザーガイドは [`/userguides`](userguides) フォルダにあります。
> ロアブックコンバーターとサイドプロンプトテンプレートライブラリは [`/resources`](resources) フォルダにあります。

---

## 📋 必須要件 (Prerequisites)

- **SillyTavern:** 1.14.0以上 (最新版を推奨)
- **シーン選択:** 開始と終了のマーカー (開始 < 終了) が設定されている必要があります。
- **チャット補完 (Chat Completion) サポート:** OpenAI, Claude, Anthropic, OpenRouter, またはその他のチャット補完 API を完全にサポートしています。
- **テキスト補完 (Text Completion) サポート:** テキスト補完 API (Kobold, TextGen など) は、チャット補完 (OpenAI 互換) API エンドポイント経由で接続されている場合にサポートされます。KoboldCpp のヒントに従ってチャット補完 API 接続を設定することをお勧めします (Ollama や他のソフトウェアの場合は必要に応じて変更してください)。その後、STMB プロファイルを設定し、「Custom (推奨)」または完全な手動設定 (Custom が失敗する場合、または複数のカスタム接続がある場合のみ) を使用してください。
**注**: テキスト補完を使用する場合、以下の設定が必須です。

### 📕 ST Memory Books を使用するための KoboldCpp のヒント
ST で以下のように設定してください (STMB が動作することを確認した後、テキスト補完に戻すことができます)。
- Chat Completion API
- Chat completion source: Custom
- エンドポイント: `http://localhost:5001/v1` (`127.0.0.1:5000/v1` も使用可能)
- "Custom API key" に何かを入力 (何でも構いませんが、ST では必須です)
- モデル ID は `koboldcpp/modelname` とする必要があります (.gguf をモデル名に入れないでください！)
- チャット補完プリセット (Chat Completion Preset) をダウンロードしてインポートします (どれでも構いません)。これにより「サポートされていません」というエラーを回避できます。
- チャット補完プリセットの最大応答長 (max response length) を少なくとも 2048 に変更してください。4096 を推奨します。(小さいと途切れるリスクがあります)

### 📕 ST Memory Books を使用するための Llama.cpp のヒント
Kobold と同様に、ST で _Chat Completion API_ として以下を設定します (STMB が動作することを確認した後、チャット補完に戻すことができます)。
- チャット補完 API 用の新しい接続プロファイルを作成
- Completion Source: `Custom (Open-AI Compatible)`
- Endpoint URL: Docker で ST を実行している場合は `http://host.docker.internal:8080/v1`、それ以外は `http://localhost:8080/v1`
- Custom API key: 何かを入力 (ST では必須)
- Model ID: `llama2-7b-chat.gguf` (または使用しているモデル。llama.cpp で複数のモデルを実行していない場合は何でも構いません)
- Prompt post-processing: none (なし)

Llama.cpp の起動には、起動を簡単にするためにシェルスクリプトまたは bat ファイルに以下のような記述をすることをお勧めします。
```sh
llama-server -m <model-path> -c <context-size> --port 8080

```

## 💡 推奨されるグローバルワールド情報/ロアブック有効化設定

* **Match Whole Words (単語の完全一致):** チェックなし (false)
* **Scan Depth (スキャン深度):** 高いほど良い (私の設定は 8 です)
* **Max Recursion Steps (最大再帰ステップ):** 2 (一般的な推奨値であり、必須ではありません)
* **Context % (コンテキスト %):** 80% (100,000 トークンのコンテキストウィンドウに基づく) - チャット履歴やボットが極端に重くないことを前提としています。

---

## 🚀 はじめに

### 1. **インストールと読み込み**

* SillyTavern をロードし、キャラクターまたはグループチャットを選択します。
* チャットメッセージに山括弧ボタン (► ◄) が表示されるのを待ちます (最大 10 秒かかる場合があります)。

### 2. **シーンのマーキング**

* シーンの最初のメッセージで ► をクリックします。
* 最後のメッセージで ◄ をクリックします。

### 3. **メモリの作成**

* 拡張機能メニュー (魔法の杖 🪄) を開き、「Memory Books」をクリックするか、`/creatememory` スラッシュコマンドを使用します。
* プロンプトが表示された場合は、設定 (プロファイル、コンテキスト、API/モデル) を確認します。
* AI による生成と自動ロアブックエントリ作成を待ちます。

---

## 🆕 スラッシュコマンド・ショートカット

* `/creatememory` : 既存の山括弧の開始/終了マーカーを使用してメモリを作成します。
* `/scenememory x-y` : メッセージ x から始まりメッセージ y で終わるメモリを作成します。
* `/nextmemory` : 前回のメモリ以降のすべてのメッセージを含むメモリを作成します。

## 👥 グループチャットのサポート

* すべての機能はグループチャットで動作します。
* シーンマーカー、メモリ作成、ロアブック統合はグループのメタデータに保存されます。
-特別な設定は必要ありません。グループチャットを選択して通常通り使用してください。

---

## 🧭 動作モード

### **自動モード (デフォルト)**

* **動作:** 現在のチャットにバインドされているロアブックを自動的に使用します。
* **推奨:** シンプルさとスピード重視の場合。ほとんどのユーザーはここから始めるべきです。
* **使用法:** キャラクターまたはグループチャットの「Chat Lorebooks (チャットロアブック)」ドロップダウンでロアブックが選択されていることを確認してください。

### **ロアブック自動作成モード (Auto-Create Lorebook Mode)** ⭐ *v4.2.0 の新機能*

* **動作:** ロアブックが存在しない場合、カスタム命名テンプレートを使用して新しいロアブックを自動的に作成し、バインドします。
* **推奨:** 新規ユーザーや素早いセットアップに。ワンクリックでのロアブック作成に最適です。
* **使用法:**
1. 拡張機能の設定で「Auto-create lorebook if none exists (存在しない場合はロアブックを自動作成)」を有効にします。
2. 命名テンプレートを設定します (デフォルト: "LTM - {{char}} - {{chat}}")。
3. バインドされたロアブックがない状態でメモリを作成すると、自動的に作成されバインドされます。


* **テンプレート プレースホルダー:** {{char}} (キャラクター名), {{user}} (あなたの名前), {{chat}} (チャット ID)
* **スマートナンバリング:** 重複する名前が存在する場合、自動的に番号 (2, 3, 4...) を追加します。
* **注:** 手動ロアブックモードとは同時に使用できません。

### **手動ロアブックモード (Manual Lorebook Mode)**

* **動作:** メインのチャットバインドロアブックを無視して、チャットごとにメモリ用の別のロアブックを選択できます。
* **推奨:** メモリを特定の別のロアブックに保存したい上級ユーザー向け。
* **使用法:**
1. 拡張機能の設定で「Enable Manual Lorebook Mode (手動ロアブックモードを有効にする)」を有効にします。
2. チャットで初めてメモリを作成するときに、ロアブックを選択するように求められます。
3. この選択は、クリアするか自動モードに戻すまで、その特定のチャットに対して保存されます。


* **注:** ロアブック自動作成モードとは同時に使用できません。

---

## 🧩 メモリの種類: シーン vs アーク

📕 Memory Books は、異なる種類の連続性のために設計された **2 つのレベルの物語メモリ** をサポートしています。

### 🎬 シーンメモリ (デフォルト)

シーンメモリは、特定のメッセージ範囲で **何が起こったか** をキャプチャします。

* 明示的なシーン選択 (► ◄) に基づく
* 瞬間ごとの回想に最適
* 会話、アクション、即時の結果を保持
* 頻繁に使用するのが最適

これは標準的で最も一般的に使用されるメモリタイプです。

---

### 🧭 アークサマリー (Arc Summaries) *(ベータ版)*

アークサマリーは、複数のシーンにわたって **時間の経過とともに何が変わったか** をキャプチャします。

イベントを要約する代わりに、アークサマリーは以下に焦点を当てます：

* キャラクターの成長と関係の変化
* 長期的な目標、緊張感、解決
* 感情の軌跡と物語の方向性
* 安定して残すべき永続的な状態変化

アークサマリーは、長く続くチャットにおけるキャラクターのブレや物語の喪失を防ぐために設計された、**より高レベルで低頻度のメモリ** です。

> 💡 アークサマリーは、シーンのログではなく、*シーズンの要約* と考えてください。

#### アークサマリーを使用するタイミング

* 大きな関係の変化があった後
* ストーリーの章やアークの終わり
* 動機、信頼、力関係が変化したとき
* 物語の新しいフェーズを開始する前

#### ベータ版の注意点

* アークサマリーはプロンプトに敏感であり、意図的に保守的です。
* ロアブックにコミットする前に確認することを推奨します。
* 優先順位の低い、またはメタスタイルのロアブックエントリと組み合わせるのが最適です。

アークサマリーは、生のチャットから直接ではなく、**既存のシーンメモリから** 生成されます。

これにより以下のメリットがあります：

* トークン使用量の削減
* AI が物語の流れをより良く理解できる

---

## 📝 メモリ生成

### **JSON のみ出力**

すべてのプロンプトとプリセットは、AI に有効な JSON のみを返すように指示する **必要があります**。例：

```json
{
  "title": "短いシーンのタイトル",
  "content": "シーンの詳細な要約...",
  "keywords": ["キーワード1", "キーワード2"]
}

```

**応答に他のテキストを含めることは許可されていません。**

### **組み込みプリセット**

1. **Summary:** 詳細なビートごとの要約。
2. **Summarize:** タイムライン、ビート、相互作用、結果のための Markdown ヘッダー。
3. **Synopsis:** 包括的で構造化された Markdown。
4. **Sum Up:** タイムライン付きの簡潔なビート要約。
5. **Minimal:** 1〜2文の要約。

### **カスタムプロンプト**

* 独自に作成できますが、上記のように有効な JSON を返す **必要があります**。

---

## 📚 ロアブック統合

* **自動エントリ作成:** 新しいメモリは、すべてのメタデータを含むエントリとして保存されます。
* **フラグベースの検出:** `stmemorybooks` フラグを持つエントリのみがメモリとして認識されます。
* **自動ナンバリング:** 複数の形式 (`[000]`, `(000)`, `{000}`, `#000`) をサポートするシーケンシャルなゼロ埋めナンバリング。
* **手動/自動順序:** プロファイルごとの挿入順序設定。
* **エディタの更新:** メモリを追加した後、オプションでロアブックエディタを自動更新します。

> **既存のメモリは変換が必要です！**
> [ロアブックコンバーター (Lorebook Converter)](https://www.google.com/search?q=/resources/lorebookconverter.html) を使用して、`stmemorybooks` フラグと必須フィールドを追加してください。

---

### 🎡 トラッカーとサイドプロンプト

サイドプロンプトはトラッカーのように使用でき、メモリロアブックにエントリを作成します。サイドプロンプトを使用すると、過去のイベントだけでなく、**進行中の状態** を追跡できます。例えば：

* 💰 インベントリとリソース (「ユーザーは何のアイテムを持っているか？」)
* ❤️ 関係ステータス (「X は Y についてどう感じているか？」)
* 📊 キャラクター統計 (「現在の体力、スキル、評判」)
* 🎯 クエストの進行状況 (「どの目標がアクティブか？」)
* 🌍 世界の状態 (「設定で何が変わったか？」)

#### **アクセス:** Memory Books 設定から「🎡 トラッカーとサイドプロンプト」をクリックします。

#### **機能:**

```
- すべてのサイドプロンプトを表示。
- 新しいプロンプトを作成したり複製したりして、さまざまなプロンプトスタイルを試すことができます。
- 任意のプリセット (組み込みを含む) を編集または削除。
- バックアップや共有のためにプリセットを JSON ファイルとしてエクスポートおよびインポート。
- 手動で実行、またはメモリ作成時に自動的に実行。

```

#### **使用のヒント:**

```
- 新しいプロンプトを作成する場合、互換性を高めるために組み込みからコピーできます。
- 追加のサイドプロンプトテンプレートライブラリ [JSON ファイル](resources/SidePromptTemplateLibrary.json) - インポートするだけで使用できます。

```

---

### 🧠 高度なカスタマイズのための正規表現 (Regex) 統合

* **テキスト処理の完全制御**: Memory Books は SillyTavern の **Regex (正規表現)** 拡張機能と統合され、2 つの重要な段階で強力なテキスト変換を適用できるようになりました。
1. **プロンプト生成**: **User Input (ユーザー入力)** の配置場所をターゲットとする正規表現スクリプトを作成することで、AI に送信されるプロンプトを自動的に変更します。
2. **応答の解析**: **AI Output (AI 出力)** の配置場所をターゲットにすることで、AI の生の応答が保存される前に、クリーンアップ、再フォーマット、または標準化を行います。


* **複数選択のサポート**: 正規表現スクリプトを複数選択できるようになりました。有効になったすべてのスクリプトは、各段階（プロンプト生成と応答解析）で順番に適用され、高度で柔軟な変換が可能になります。
* **仕組み**: 統合はシームレスです。Regex 拡張機能で目的のスクリプトを作成して有効化（複数選択）するだけで、Memory Books はメモリおよびサイドプロンプトの作成中にそれらを自動的に適用します。

---

## 👤 プロファイル管理

* **プロファイル:** 各プロファイルには、API、モデル、温度、プロンプト/プリセット、タイトル形式、およびロアブック設定が含まれます。
* **インポート/エクスポート:** プロファイルを JSON として共有します。
* **プロファイル作成:** 詳細オプションポップアップを使用して、新しいプロファイルを保存します。
* **プロファイルごとのオーバーライド:** メモリ作成のために API/モデル/温度を一時的に切り替え、その後元の設定を復元します。

---

## ⚙️ 設定と構成

### **グローバル設定**

[Youtube での短い概要ビデオ](https://youtu.be/mG2eRH_EhHs)

* **Manual Lorebook Mode (手動ロアブックモード):** チャットごとにロアブックを選択できるように有効にします。
* **Auto-create lorebook if none exists (存在しない場合はロアブックを自動作成):** ⭐ *v4.2.0 の新機能* - 命名テンプレートを使用してロアブックを自動的に作成およびバインドします。
* **Lorebook Name Template (ロアブック名テンプレート):** ⭐ *v4.2.0 の新機能* - {{char}}, {{user}}, {{chat}} プレースホルダーを使用して自動作成されるロアブック名をカスタマイズします。
* **Allow Scene Overlap (シーンの重複を許可):** 重複するメモリ範囲を許可または防止します。
* **Always Use Default Profile (常にデフォルトプロファイルを使用):** 確認ポップアップをスキップします。
* **Show memory previews (メモリプレビューを表示):** ロアブックに追加する前にメモリを確認および編集するためのプレビューポップアップを有効にします。
* **Show Notifications (通知を表示):** トーストメッセージのオン/オフを切り替えます。
* **Refresh Editor (エディタを更新):** メモリ作成後にロアブックエディタを自動更新します。
* **Token Warning Threshold (トークン警告しきい値):** 大きなシーンの警告レベルを設定します (デフォルト: 30,000)。
* **Default Previous Memories (デフォルトの過去メモリ):** コンテキストとして含める以前のメモリの数 (0-7)。
* **Auto-create memory summaries (メモリ要約の自動作成):** 間隔を置いて自動メモリ作成を有効にします。
* **Auto-Summary Interval (自動要約間隔):** メモリ要約を自動作成するまでのメッセージ数 (10-200、デフォルト: 100)。
* **Memory Title Format (メモリタイトル形式):** 選択またはカスタマイズします (下記参照)。

### **プロファイル フィールド**

* **Name:** 表示名。
* **API/Provider:** openai, claude, custom など。
* **Model:** モデル名 (例: gpt-4, claude-3-opus)。
* **Temperature:** 0.0–2.0。
* **Prompt or Preset:** カスタムまたは組み込み。
* **Title Format:** プロファイルごとのテンプレート。
* **Activation Mode:** Vectorized (ベクトル化), Constant (定数), Normal (通常)。
* **Position:** ↑Char, ↓Cha, ↑EM, ↓EM, ↑AN, Outlet (およびフィールド名)。
* **Order Mode:** Auto (自動) / manual (手動)。
* **Recursion:** 再帰を防止/遅延。

---

## 🏷️ タイトルのフォーマット

強力なテンプレートシステムを使用して、ロアブックエントリのタイトルをカスタマイズします。

* **プレースホルダー:**
* `{{title}}` - AI によって生成されたタイトル (例: "運命の出会い")。
* `{{scene}}` - メッセージ範囲 (例: "シーン 15-23")。
* `{{char}}` - キャラクターの名前。
* `{{user}}` - ユーザー名。
* `{{messages}}` - シーン内のメッセージ数。
* `{{profile}}` - 生成に使用されたプロファイルの名前。
* 様々な形式の現在の日付/時刻プレースホルダー (例: 日付は `August 13, 2025`、時刻は `11:08 PM`)。


* **自動ナンバリング:** シーケンシャルなゼロ埋めナンバリングのために、`[0]`, `[00]`, `(0)`, `{0}`, `#0` に加え、`#[000]`, `([000])`, `{[000]}` のようなラップされた形式も使用できます。
* **カスタムフォーマット:** 独自のフォーマットを作成できます。v4.5.1 以降、印刷可能なすべての Unicode 文字 (絵文字、CJK、アクセント付き文字、記号などを含む) がタイトルで使用可能です。Unicode 制御文字のみがブロックされます。

---

## 🧵 コンテキストメモリ

* **最大 7 つの過去のメモリを含める** ことで、より良い連続性をコンテキストとして持たせることができます。
* **トークン見積もり** には、正確性のためにコンテキストメモリが含まれます。

---

## 🎨 視覚的フィードバックとアクセシビリティ

* **ボタンの状態:**
* 非アクティブ、アクティブ、有効な選択、シーン内、処理中。


* **アクセシビリティ:**
* キーボードナビゲーション、フォーカスインジケーター、ARIA 属性、視差効果の低減 (reduced motion)、モバイル対応。



---

# FAQ (よくある質問)

### 拡張機能メニューに Memory Books が見つかりません！

設定は拡張機能メニュー (入力ボックスの左側にある魔法の杖 🪄) にあります。「Memory Books」を探してください。

### ベクトル (Vectors) を実行する必要がありますか？

ワールド情報の 🔗 エントリは、ST の UI では「vectorized (ベクトル化)」という名前になっています。これが私が vectorized という言葉を使う理由です。Vectors 拡張機能を使用していない場合 (私は使用していません) は、キーワードを介して機能します。これはすべて自動化されているため、どのキーワードを使用するかを考える必要はありません。

### メモリ用に別のロアブックを作成すべきですか？それとも他の用途ですでに使用しているものと同じロアブックを使用できますか？

メモリ用ロアブックは別のブックにすることをお勧めします。これにより、メモリの整理が (他のエントリと比較して) 簡単になります。たとえば、グループチャットへの追加、別のチャットでの使用、または (STLO を使用した) 個別のロアブック予算の設定などです。

### Memory Books が唯一のロアブックである場合、「Delay until recursion (再帰まで遅延)」を使用すべきですか？

いいえ。他のワールド情報やロアブックがない場合、「Delay until recursion」を選択すると、最初のループがトリガーされず、何もアクティブにならない可能性があります。Memory Books が唯一のロアブックである場合は、「Delay until recursion」を無効にするか、少なくとも 1 つの追加のワールド情報/ロアブックが設定されていることを確認してください。

---

# トラブルシューティング

* **ロアブックが利用できないか、選択されていない:**
* 手動モードの場合、プロンプトが表示されたらロアブックを選択してください。
* 自動モードの場合、ロアブックをチャットにバインドしてください。
* または、「Auto-create lorebook if none exists (存在しない場合はロアブックを自動作成)」を有効にして自動作成します。


* **シーンが選択されていない:**
* 開始 (►) ポイントと終了 (◄) ポイントの両方をマークしてください。


* **シーンが既存のメモリと重複している:**
* 別の範囲を選択するか、設定で「Allow scene overlap (シーンの重複を許可)」を有効にしてください。


* **AI が有効なメモリの生成に失敗した:**
* JSON 出力をサポートするモデルを使用してください。
* プロンプトとモデルの設定を確認してください。


* **トークン警告しきい値を超えた:**
* より小さなシーンを使用するか、しきい値を上げてください。


* **山括弧ボタンがない:**
* 拡張機能が読み込まれるのを待つか、リフレッシュしてください。


* **キャラクターデータが利用できない:**
* チャット/グループが完全に読み込まれるのを待ってください。



---

## 📝 文字ポリシー (v4.5.1+)

* **タイトルで許可:** すべての印刷可能な Unicode 文字が許可されています。これには、アクセント付き文字、絵文字、CJK (中日韓)、記号が含まれます。
* **ブロック:** Unicode 制御文字 (U+0000–U+001F, U+007F–U+009F) のみがブロックされ、これらは自動的に削除されます。

## 例と移行に関する注意点については、[文字ポリシーの詳細 (Character Policy Details)](https://www.google.com/search?q=charset.md) を参照してください。

*VS Code/Cline、広範なテスト、そしてコミュニティからのフィードバックにより、愛を込めて開発されました。* 🤖💕
