# 📕 Memory Books (SillyTavern 扩展)

这是下一代 SillyTavern（酒馆）扩展，用于自动、结构化且可靠地创建记忆。在聊天中标记场景，利用 AI 生成基于 JSON 的总结，并将它们作为“[向量化](#vectorized)”条目存储在您的世界书（Lorebook）中。支持群聊、高级配置文件管理以及极其稳定的 API/模型处理。

### ❓ 词汇表
- Scene (场景) → Memory (记忆)
- Many Scenes (多个场景) → Arc Summary (篇章总结)
- Always-On (常驻) → Side Prompt / Tracker (侧边提示词/追踪器)

## ❗ 请先阅读！

从这里开始：
* ⚠️‼️请阅读 [前置条件](#-前置条件) 以获取安装注意事项（特别是如果您运行文本补全 API）。
* ❓ [常见问题 (FAQ)](#FAQ)
* 🛠️ [故障排除](#故障排除)

其他链接：
* 📘 [用户指南 (英文)](USER_GUIDE.md)
* 📋 [版本历史 & 更新日志](changelog.md)
* 💡 [配合 📚 Lorebook Ordering 使用 📕 Memory Books](https://github.com/aikohanasaki/SillyTavern-LorebookOrdering/blob/main/guides/STMB%20and%20STLO%20-%20English.md)

---

### 📚 配合 Lorebook Ordering (STLO) 提升体验

为了实现高级的记忆组织和更深层次的故事整合，我们强烈建议将 STMB 与 [SillyTavern-LorebookOrdering (STLO)](https://github.com/aikohanasaki/SillyTavern-LorebookOrdering/blob/main/guides/STMB%20and%20STLO%20-%20English.md) 一起使用。请参阅指南以获取最佳实践、设置说明和技巧！

> 注意：支持多种语言：请参阅 [`/locales`](locales) 文件夹查看列表。国际化/本地化的自述文件和用户指南可以在 [`/userguides`](userguides) 文件夹中找到。
> 世界书转换器和侧边提示词模板库位于 [`/resources`](resources) 文件夹中。

---

## 📋 前置条件 (Prerequisites)

- **SillyTavern:** 1.14.0+ (建议使用最新版)
- **场景选择:** 必须设置开始和结束标记 (开始 < 结束)。
- **聊天补全支持 (Chat Completion):** 完全支持 OpenAI, Claude, Anthropic, OpenRouter 或其他聊天补全 API。
- **文本补全支持 (Text Completion):** 当通过聊天补全 (OpenAI-兼容) API 端点连接时，支持文本补全 API (Kobold, TextGen 等)。我建议按照下方的 KoboldCpp 提示设置聊天补全 API 连接（如果您使用的是 Ollama 或其他软件，请按需更改）。之后，设置一个 STMB 配置文件并使用“Custom (自定义)”（推荐）或全手动配置（仅当自定义失败或您有多个自定义连接时）。
**注意**: 请注意，如果您使用文本补全，您必须...

### 📕 ST Memory Books 的 KoboldCpp 使用技巧
在 ST 中进行如下设置（您可以在 STMB 正常工作后切回文本补全模式）：
- API 选择 Chat Completion (聊天补全)
- 选择 Custom (自定义) 聊天补全源
- 端点使用 `http://localhost:5001/v1` (也可以使用 `127.0.0.1:5000/v1`)
- 在 "custom API key" 中输入任何内容 (无所谓，但 ST 要求填一个)
- 模型 ID 必须是 `koboldcpp/modelname` (不要在模型名称中包含 .gguf！)
- 下载一个聊天补全预设 (Chat Completion Preset) 并导入它 (任何一个都可以)，仅仅是为了让你**拥有**一个聊天补全预设。这避免了“不支持 (not supported)”的错误。
- 更改聊天补全预设的最大响应长度 (max response length)，使其至少为 2048；推荐 4096。(太小意味着你面临被截断的风险。)

### 📕 ST Memory Books 的 Llama.cpp 使用技巧
就像 Kobold 一样，在 ST 中将其设置为 _聊天补全 API_ (验证 STMB 工作正常后，您可以切回文本补全)：
- 为聊天补全 API 创建一个新的连接配置文件
- 补全源 (Completion Source): `Custom (Open-AI Compatible)`
- 端点 URL (Endpoint URL): 如果在 docker 中运行 ST，则为 `http://host.docker.internal:8080/v1`，否则为 `http://localhost:8080/v1`
- 自定义 API 密钥 (Custom API key): 输入任何内容 (ST 要求填一个)
- 模型 ID: `llama2-7b-chat.gguf` (或者你的模型名，如果你在 llama.cpp 中只运行一个模型，这并不重要)
- 提示词后处理 (Prompt post-processing): 无 (none)

为了启动 Llama.cpp，我建议将类似以下的内容放入 shell 脚本或 bat 文件中，以便更容易启动：
```sh
llama-server -m <model-path> -c <context-size> --port 8080

```

## 💡 推荐的全局世界信息/世界书激活设置

* **匹配全词 (Match Whole Words):** 保持未选中 (false)
* **扫描深度 (Scan Depth):** 越高越好 (我设置为 8)
* **最大递归步数 (Max Recursion Steps):** 2 (一般建议，非必须)
* **上下文百分比 (Context %):** 80% (基于 100,000 token 的上下文窗口) - 假设您没有超长的聊天记录或庞大的角色设定。

---

## 🚀 快速开始

### 1. **安装 & 加载**

* 加载 SillyTavern 并选择一个角色或群聊。
* 等待聊天消息上出现箭头按钮 (► ◄)（最多可能需要 10 秒）。

### 2. **标记场景**

* 点击场景第一条消息上的 ►。
* 点击最后一条消息上的 ◄。

### 3. **创建记忆**

* 打开扩展菜单 (魔法棒图标 🪄) 并点击 "Memory Books"，或使用 `/creatememory` 斜杠命令。
* 如果提示确认设置（配置文件、上下文、API/模型），请确认。
* 等待 AI 生成并自动写入世界书条目。

---

## 🆕 斜杠命令快捷方式

* `/creatememory` 将使用现有的箭头开始/结束标记来创建记忆。
* `/scenememory x-y` 将创建一个从消息 x 开始到消息 y 结束的记忆。
* `/nextmemory` 将创建一个包含自上次记忆以来所有消息的记忆。

## 👥 群聊支持

* 所有功能均适用于群聊。
* 场景标记、记忆创建和世界书集成都存储在群组元数据中。
* 无需特殊设置——只需选择群聊并正常使用即可。

---

## 🧭 操作模式

### **自动模式 (默认)**

* **工作原理:** 自动使用绑定到当前聊天的世界书。
* **适用场景:** 简单快捷。大多数用户应从这里开始。
* **使用方法:** 确保在您的角色或群聊的“聊天世界书 (Chat Lorebooks)”下拉菜单中选择了一个世界书。

### **自动创建世界书模式** ⭐ *v4.2.0 新增*

* **工作原理:** 当不存在世界书时，使用您的自定义命名模板自动创建并绑定一个新的世界书。
* **适用场景:** 新用户和快速设置。非常适合一键创建世界书。
* **使用方法:**
1. 在扩展设置中启用 "Auto-create lorebook if none exists" (若不存在则自动创建世界书)。
2. 配置您的命名模板 (默认: "LTM - {{char}} - {{chat}}")。
3. 当您在没有绑定世界书的情况下创建记忆时，系统会自动创建并绑定一个。


* **模板占位符:** {{char}} (角色名), {{user}} (您的名字), {{chat}} (聊天 ID)
* **智能编号:** 如果存在重复名称，自动添加数字 (2, 3, 4...)。
* **注意:** 不能与“手动世界书模式”同时使用。

### **手动世界书模式**

* **工作原理:** 允许您按聊天为记忆选择不同的世界书，忽略绑定的主聊天世界书。
* **适用场景:** 希望将记忆定向到特定的、独立的世界书的高级用户。
* **使用方法:**
1. 在扩展设置中启用 "Enable Manual Lorebook Mode" (启用手动世界书模式)。
2. 第一次在聊天中创建记忆时，系统会提示您选择一个世界书。
3. 此选择将针对该特定聊天保存，直到您清除它或切换回自动模式。


* **注意:** 不能与“自动创建世界书模式”同时使用。

---

## 🧩 记忆类型：场景 (Scenes) vs 篇章 (Arcs)

📕 Memory Books 支持 **两个层级的叙事记忆**，分别针对不同类型的连续性设计。

### 🎬 场景记忆 (默认)

场景记忆捕捉特定消息范围内 **发生了什么**。

* 基于明确的场景选择 (► ◄)
* 适合即时回忆
* 保留对话、动作和直接结果
* 最好频繁使用

这是标准且最常用的记忆类型。

---

### 🧭 篇章总结 *(Beta)*

篇章总结捕捉跨越多个场景 **随时间发生的变化**。

与总结事件不同，篇章总结侧重于：

* 角色发展和关系转变
* 长期目标、紧张局势和决议
* 情感轨迹和叙事方向
* 应保持稳定的持久状态变化

篇章总结是 **更高级别、频率更低** 的记忆，旨在防止长期聊天中的角色漂移和叙事丢失。

> 💡 将篇章总结视为 *剧季回顾*，而不是场景日志。

#### 何时使用篇章总结

* 在发生重大关系转变后
* 在故事章节或篇章结束时
* 当动机、信任或权力动态发生变化时
* 在开始故事的新阶段之前

#### Beta 说明

* 篇章总结对提示词敏感，且设计上较为保守
* 建议在提交到世界书之前进行审查
* 最好与低优先级或元数据风格的世界书条目搭配使用

篇章总结是 **从现有的场景记忆** 生成的，而不是直接从原始聊天记录生成的。

这为您提供了：

* 减少 token 使用
* AI 对叙事流有更好的理解

---

## 📝 记忆生成

### **仅限 JSON 输出**

所有提示词和预设 **必须** 指示 AI 仅返回有效的 JSON，例如：

```json
{
  "title": "简短的场景标题",
  "content": "场景的详细总结...",
  "keywords": ["关键词1", "关键词2"]
}

```

**响应中不允许包含其他文本。**

### **内置预设**

1. **Summary:** 详细的逐个节拍总结。
2. **Summarize:** 带有时间线、节拍、互动、结果的 Markdown 标题。
3. **Synopsis:** 全面、结构化的 markdown。
4. **Sum Up:** 带有时间线的简明节拍总结。
5. **Minimal:** 1-2 句话的总结。

### **自定义提示词**

* 创建您自己的提示词，但 **必须** 如上所述返回有效的 JSON。

---

## 📚 世界书集成

* **自动条目创建:** 新记忆作为包含所有元数据的条目存储。
* **基于标志的检测:** 只有带有 `stmemorybooks` 标志的条目才会被识别为记忆。
* **自动编号:** 顺序、零填充编号，支持多种格式 (`[000]`, `(000)`, `{000}`, `#000`)。
* **手动/自动排序:** 每个配置文件的插入顺序设置。
* **编辑器刷新:** 可选在添加记忆后自动刷新世界书编辑器。

> **现有记忆必须转换！**
> 使用 [Lorebook Converter](https://www.google.com/search?q=/resources/lorebookconverter.html) 添加 `stmemorybooks` 标志和必填字段。

---

### 🎡 追踪器 & 侧边提示词 (Side Prompts)

侧边提示词可以像追踪器一样使用，并会在您的记忆世界书中创建条目。侧边提示词允许您追踪 **当前状态**，而不仅仅是过去的事件。例如：

* 💰 物品与资源 ("用户拥有什么物品？")
* ❤️ 关系状态 ("X 对 Y 感觉如何？")
* 📊 角色属性 ("当前健康、技能、声望")
* 🎯 任务进度 ("哪些目标处于激活状态？")
* 🌍 世界状态 ("设定中发生了什么变化？")

#### **访问:** 从 Memory Books 设置中，点击 “🎡 追踪器 & 侧边提示词”。

#### **功能:**

```
- 查看所有侧边提示词。
- 创建新提示词或复制提示词以尝试不同的提示词风格。
- 编辑或删除任何预设（包括内置预设）。
- 将预设导出和导入为 JSON 文件以进行备份或共享。
- 手动运行它们，或随记忆创建自动运行。

```

#### **使用技巧:**

```
- 创建新提示词时，您可以从内置提示词复制以获得最佳兼容性。
- 额外的侧边提示词模板库 [JSON 文件](resources/SidePromptTemplateLibrary.json) - 导入即可使用

```

---

### 🧠 Regex (正则表达式) 集成实现高级自定义

* **完全控制文本处理**: Memory Books 现在与 SillyTavern 的 **Regex** 扩展集成，允许您在两个关键阶段应用强大的文本转换：
1. **提示词生成**: 通过创建针对 **用户输入 (User Input)** 位置的正则脚本，自动修改发送给 AI 的提示词。
2. **响应解析**: 通过针对 **AI 输出 (AI Output)** 位置，在保存 AI 的原始响应之前对其进行清理、重新格式化或标准化。


* **支持多选**: 您现在可以多选正则脚本。所有启用的脚本将在每个阶段（提示词生成和响应解析）按顺序应用，允许进行高级且灵活的转换。
* **工作原理**: 集成是无缝的。只需在 Regex 扩展中创建并启用（多选）您想要的脚本，Memory Books 将在记忆和侧边提示词创建期间自动应用它们。

---

## 👤 配置文件管理 (Profile Management)

* **配置文件:** 每个配置文件包括 API、模型、温度、提示词/预设、标题格式和世界书设置。
* **导入/导出:** 将配置文件作为 JSON 分享。
* **配置文件创建:** 使用高级选项弹出窗口保存新配置文件。
* **每个配置文件的覆盖:** 临时切换 API/模型/温度以创建记忆，然后恢复您的原始设置。

---

## ⚙️ 设置与配置

### **全局设置**

[Youtube 上的简短视频概览](https://youtu.be/mG2eRH_EhHs)

* **Manual Lorebook Mode (手动世界书模式):** 启用以按聊天选择世界书。
* **Auto-create lorebook if none exists (若无则自动创建世界书):** ⭐ *v4.2.0 新增* - 使用您的命名模板自动创建并绑定世界书。
* **Lorebook Name Template (世界书命名模板):** ⭐ *v4.2.0 新增* - 使用 {{char}}, {{user}}, {{chat}} 占位符自定义自动创建的世界书名称。
* **Allow Scene Overlap (允许场景重叠):** 允许或阻止重叠的记忆范围。
* **Always Use Default Profile (始终使用默认配置文件):** 跳过确认弹窗。
* **Show memory previews (显示记忆预览):** 启用预览弹窗，以便在添加到世界书之前查看和编辑记忆。
* **Show Notifications (显示通知):** 切换 Toast 消息提示。
* **Refresh Editor (刷新编辑器):** 创建记忆后自动刷新世界书编辑器。
* **Token Warning Threshold (Token 警告阈值):** 设置大场景的警告级别（默认：30,000）。
* **Default Previous Memories (默认前序记忆):** 作为上下文包含的先前记忆数量 (0-7)。
* **Auto-create memory summaries (自动创建记忆总结):** 按间隔启用自动记忆创建。
* **Auto-Summary Interval (自动总结间隔):** 自动创建记忆总结的消息数量间隔 (10-200, 默认: 100)。
* **Memory Title Format (记忆标题格式):** 选择或自定义（见下文）。

### **配置文件字段**

* **Name:** 显示名称。
* **API/Provider:** openai, claude, custom 等。
* **Model:** 模型名称 (例如 gpt-4, claude-3-opus)。
* **Temperature:** 0.0–2.0。
* **Prompt or Preset:** 自定义或内置。
* **Title Format:** 每个配置文件的模板。
* **Activation Mode (激活模式):** Vectorized (向量化), Constant (常驻), Normal (普通)。
* **Position (位置):** ↑Char, ↓Cha, ↑EM, ↓EM, ↑AN, Outlet (以及字段名称)。
* **Order Mode (排序模式):** Auto (自动)/Manual (手动)。
* **Recursion (递归):** 阻止/延迟递归。

---

## 🏷️ 标题格式化

使用强大的模板系统自定义您的世界书条目标题。

* **占位符:**
* `{{title}}` - AI 生成的标题 (例如 "命运般的相遇")。
* `{{scene}}` - 消息范围 (例如 "Scene 15-23")。
* `{{char}}` - 角色名称。
* `{{user}}` - 您的用户名。
* `{{messages}}` - 场景中的消息数量。
* `{{profile}}` - 用于生成的配置文件名称。
* 各种格式的当前日期/时间占位符 (例如 `August 13, 2025` 表示日期, `11:08 PM` 表示时间)。


* **自动编号:** 使用 `[0]`, `[00]`, `(0)`, `{0}`, `#0`，以及现在的包裹形式如 `#[000]`, `([000])`, `{[000]}` 进行顺序、零填充编号。
* **自定义格式:** 您可以创建自己的格式。从 v4.5.1 开始，标题中允许使用所有可打印的 Unicode 字符（包括表情符号、CJK、重音符号、符号等）；仅阻止 Unicode 控制字符。

---

## 🧵 上下文记忆

* **包含最多 7 个先前的记忆** 作为上下文，以获得更好的连续性。
* **Token 估算** 包含上下文记忆以确保准确性。

---

## 🎨 视觉反馈与辅助功能

* **按钮状态:**
* Inactive (非活动), active (活动), valid selection (有效选择), in-scene (场景中), processing (处理中)。


* **辅助功能:**
* 键盘导航，焦点指示器，ARIA 属性，减少动画，移动端友好。



---

# FAQ (常见问题)

### 我在扩展菜单里找不到 Memory Books！

设置位于扩展菜单中（输入框左侧的魔法棒图标 🪄）。寻找 "Memory Books"。

### 我需要运行 Vectors (向量) 吗？

世界信息中的 🔗 条目在 ST 的 UI 中被命名为 "vectorized" (向量化)。这就是为什么我使用 vectorized 这个词。如果您不使用 vectors 扩展（我不使用），它通过关键词工作。这都是自动化的，所以您不必考虑使用什么关键词。

### 我应该为记忆制作一个单独的世界书，还是可以使用我已经用于其他事情的同一个世界书？

我建议您的记忆世界书应该是一本单独的书。这使得组织记忆（相对于其他条目）更容易。例如，将其添加到群聊，在另一个聊天中使用它，或者设置单独的世界书预算（使用 STLO）。

### 如果 Memory Books 是唯一的世界书，我应该使用 'Delay until recursion' (延迟直到递归) 吗？

不。如果没有其他世界信息或世界书，选择 'Delay until recursion' 可能会阻止第一次循环触发，导致没有任何内容被激活。如果 Memory Books 是唯一的世界书，请禁用 'Delay until recursion' 或确保至少配置了一个额外的世界信息/世界书。

---

# 故障排除 (Troubleshooting)

* **没有可用或选定的世界书:**
* 在手动模式下，根据提示选择一个世界书。
* 在自动模式下，将一个世界书绑定到您的聊天。
* 或者启用 "Auto-create lorebook if none exists" 进行自动创建。


* **未选择场景:**
* 标记开始 (►) 和结束 (◄) 点。


* **场景与现有记忆重叠:**
* 选择不同的范围，或在设置中启用 "Allow scene overlap" (允许场景重叠)。


* **AI 无法生成有效记忆:**
* 使用支持 JSON 输出的模型。
* 检查您的提示词和模型设置。


* **超过 Token 警告阈值:**
* 使用较小的场景，或增加阈值。


* **缺少箭头按钮:**
* 等待扩展加载，或刷新。


* **角色数据不可用:**
* 等待聊天/群组完全加载。



---

## 📝 字符策略 (v4.5.1+)

* **标题中允许:** 允许所有可打印的 Unicode 字符，包括重音字母、表情符号、CJK 和符号。
* **被阻止:** 仅阻止 Unicode 控制字符 (U+0000–U+001F, U+007F–U+009F)；这些字符会被自动移除。

## 请参阅 [字符策略详情](https://www.google.com/search?q=charset.md) 以获取示例和迁移说明。

*用爱心开发，使用 VS Code/Cline，经过广泛测试和社区反馈。* 🤖💕
